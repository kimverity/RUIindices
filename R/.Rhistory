get_descendant_branches <- function(tree, node){
root <- FALSE
if (node == (length(tree$tip.label)+1)){ # Is the root node
root <- TRUE
branches <- which(tree$edge[,1] == node) # Select row index of direct descendant branches
if (length(branches) == 0) { # If no descendant branches return empty matrix
return(data.frame("Start_node" = numeric(), "End_node" = numeric(),
"Branch_length" = numeric(), "x" = numeric()))}
else{
descendants <- c() # Empty array to store descendants
for (i in 1:length(branches)){ # Calculates row index of all branches descendant from node
descendants <- append(descendants, which(DescendantEdges(edge = branches[i],
tree$edge[,1], tree$edge[,2])))
}
}
}else{ # Not root node
branch <- which(tree$edge[,2] == node) # Select row index of direct descendant branches
if (length(branch) == 0) { # If no descendant branches return empty matrix
return(data.frame("Start_node" = numeric(), "End_node" = numeric(),
"Branch_length" = numeric(), "x" = numeric()))}
else{
descendants <- which(DescendantEdges(tree$edge[,1], tree$edge[,2], edge = branch))
}
}
sub_tree <- tree$edge[descendants,] # Select subtree from node
x <- sapply(sub_tree[,2], distance, top_node=node, tree=tree) # Record distance between node and end of each branch
# Store information
df_branch_info <- data.frame("Start_node" = sub_tree[,1], "End_node" = sub_tree[,2],
"Branch_length" = tree$edge.length[descendants],
"x" = x)
# Delete any branches with branch length zero
if (root == FALSE){
df_branch_info <- df_branch_info[-1,]
}
return(df_branch_info)
}
# Calculates T_i and S_i for a given node i in a phylogenetic tree
compute_T_i_S_i <- function(tree, node, abundances) {
# Choose branches that are immediate descendants of node and record data in dataframe
df_descen_info <- data.frame("Start_node" = tree$edge[tree$edge[, 1] == node, 1],
"End_node" = tree$edge[tree$edge[, 1] == node, 2],
"Branch_lengths" = tree$edge.length[which(tree$edge[, 1] == node)])
# Delete any zero length branch lengths
df_descen_info <- df_descen_info[!(df_descen_info$Branch_lengths == 0), ]
Length <- length(unique(df_descen_info[,"Branch_lengths"]))
df_list <- vector(mode = "list", length = Length) # List for dataframes
T_i <- 0 # Initialise T_i sum
prev_x <- 0 # Keep track of previous value of x
for (j in 1:Length) { # For each branch as all could have different branch lengths
abundance_sum <- 0 # Initialise sum
if (nrow(df_descen_info) != 0){ # Checks if any branches are left
for (i in 1:nrow(df_descen_info)) { # Sum over all branches in current region
if (!(is.na(df_descen_info["End_node"][i,]))){
end_node <- df_descen_info["End_node"][i,] # Select end node of current branch
abundance_sum <- abundance_sum + abundances[[as.character(end_node)]] # Sum abundances
}
}
}
# Record all info and delete any branches "passed"
if (nrow(df_descen_info) != 0){ # If there are branches left
df_list[j] <- list(data.frame("S_i" = abundance_sum,
"x" = min(df_descen_info["Branch_lengths"]))) # Append abundance and corresponding value of x
T_i <- T_i + (abundance_sum * (min(df_descen_info["Branch_lengths"]) - prev_x)) # Sum T_i
prev_x <- min(df_descen_info["Branch_lengths"]) # Update previous x
df_descen_info <- df_descen_info[-(which(df_descen_info["Branch_lengths"] == min(df_descen_info["Branch_lengths"]))),] # Remove branch/s corresponding to x value
}
}
# Combine dataframes
DF_S_i <- Reduce(rbind, df_list)
return(list(T_i, DF_S_i))
}
# Calculate S_i_a for a given node i and ancestor a in a phylogenetic tree
calculate_S_i_a <- function(tree, node, abundances, curr_ancestor, h, l_i) {
temp <- function(a,b){return(a[[b]])}
if (node != curr_ancestor){ # If not considering itself as ancestor
df_node_info <- get_descendant_branches(tree, curr_ancestor) # Get descendant branches from ancestor
df_node_info <- df_node_info[df_node_info$x > h,] # Select branches that pass node
curr_index <- which(df_node_info[,"x"] - df_node_info[,"Branch_length"] < h)
df_node_info[curr_index,"Branch_length"] <- df_node_info[curr_index,"x"] - h  # For any branches that start before the node, correct branch lengths to be measured from node
df_node_info$x <- df_node_info$x - h # Change distance to be distance from node to end of branch
}else{ # Considering itself as ancestor
df_node_info <- get_descendant_branches(tree, node) # All descendant branches from node in dataframe
}
# Delete any branches with branch length zero
df_node_info <- df_node_info[!(df_node_info$Branch_length == 0), ]
df_node_info_ed <- df_node_info
#Length <- length(unique(df_node_info[df_node_info$x <= l_i,]))
Length <- length(df_node_info_ed$Branch_length)
df_list <- vector(mode = "list", length = Length) # List for dataframes
abund_list <- vector(mode = "list", length = Length) # Empty dictionary for abundances
x <- 0 # Keep track of distance from node
for (j in 1:Length) { # For each branch as all could have different branch lengths
if (x != l_i){
index_curr_branches <- which(df_node_info_ed[,"x"] %==% df_node_info_ed[,"Branch_length"]) # Row index of current branches
if (nrow(df_node_info_ed) != 0){
abund_list[[j]] <- sapply(as.character(end_node <- df_node_info_ed[index_curr_branches,"End_node"]),
temp, a = abundances) # Store all branch abundances present for this value of x
abundance_sum <- sum(abund_list[[j]])
#print(abundance_sum)
df_list[j] <- list(data.frame("S_i" = abundance_sum,
"x" = (min(df_node_info_ed[index_curr_branches,]["x"]) + x))) # Append abundance and corresponding value of x
prev_x <- min(df_node_info_ed[index_curr_branches,]["x"]) # Update previous x
x <- x + prev_x # Update x
index_to_be_deleted <- which(df_node_info_ed[,"x"] %==% min(df_node_info_ed[index_curr_branches,]["x"])) # Indices of rows to be deleted
df_node_info_ed$x <- df_node_info_ed$x - prev_x # "Reset" x = 0 level
df_node_info_ed[index_curr_branches,]["Branch_length"] <- df_node_info_ed[index_curr_branches,]["Branch_length"] - prev_x # Shorten current branch lengths by previous x
df_node_info_ed <- df_node_info_ed[-index_to_be_deleted,] # Remove branch/s corresponding to value of x
}
}else{
break
}
}
# Delete unused entries
df_list <- Filter(Negate(is.null), df_list)
abund_list <- Filter(Negate(is.null), abund_list)
# Combine dataframes
DF_S_i <- Reduce(rbind, df_list)
return(list(DF_S_i, abund_list))
}
# Calculates qD/1J or all for given node i, ancestor a and q value
calculate_DJ_i_a <- function(tree, node, abundances, curr_ancestor, h, l_i,
index_letter, q, individual){
S_i_a_res <- calculate_S_i_a(tree,node,abundances, curr_ancestor, h, l_i) # Run function
df_S_i_a <- S_i_a_res[[1]] # Select dataframe
abund_list <- S_i_a_res[[2]] # Select abundance list
# Function to calculate the index/indices sum/s
sum_function <- function(abund_vec, S, individual, index_letter){
if (individual == TRUE) { # Calculating one index
# Checks desired index and calculates value
if (index_letter == "J") { # J
# J is defined to be 1 when only one branch is present
if (length(abund_vec) != 1) { # There is more than one branch in region
ind_val <- sum(-(abund_vec / S) * log((abund_vec / S),
base=length(abund_vec)))
}else if (length(abund_vec) == 1) { # There is one branch in region
ind_val <- 1
}
}else { # D
# Checks q and calculates corresponding index
if (q == 1) {
ind_val <- sum(-(abund_vec / S) * log((abund_vec / S)))
}else if (q == 0) {
ind_val <- log(length(abund_vec))
}
}
return(ind_val)
}else if (individual == FALSE) { # Calculate all indices
D1 <- sum(-(abund_vec / S) * log((abund_vec / S)))
D0 <- log(length(abund_vec))
if (length(abund_vec) != 1) { # There is more than one branch in region
J1 <- sum(-(abund_vec / S) * log((abund_vec / S),
base=length(abund_vec)))
}else if (length(abund_vec) == 1) { # There is one branch in region
J1 <- 1
}
return(c(D0, D1, J1))
}
}
# Calculate index values
values <- mapply(sum_function, abund_vec = abund_list, S = df_S_i_a$S_i,
individual=individual, index_letter=index_letter)
# Return either a dictionary of dataframes with index values or
# a single dataframe with desired index values
if (individual == FALSE) { # All indices
return(list("1DN" = data.frame("D1" = values[2,], "x" = df_S_i_a$x),
"1JN" = data.frame("J1" = values[3,], "x" = df_S_i_a$x),
"0DN" = data.frame("D0" = values[1,], "x" = df_S_i_a$x)))
}else if (individual == TRUE) { # Single index
return(data.frame("In" = values, "x" = df_S_i_a$x))
}
}
# Calculate S_i_a by first attaching all of trees branches to root node/creates star tree
calculate_S_i_a_star <- function(tree, node, abundance_data) {
temp <- function(a,b){return(a[[b]])}
abundances <- abundance_phylo(tree, abundance_data)
df_node_info <- get_descendant_branches(tree, node) # Get descendant branches from ancestor
df_node_info$x <- df_node_info$Branch_length
df_node_info_ed <- df_node_info
Length <- length(unique(df_node_info$x))
df_list <- vector(mode = "list", length = Length) # List for dataframes
abund_list <- vector(mode = "list", length = Length) # Empty dictionary for abundances
df_list <- list()
for (j in 1:Length) { # For each branch as all could have different branch lengths
if (nrow(df_node_info_ed) != 0){
end_nodes <- df_node_info_ed$End_node
abund_list[[j]] <- sapply(as.character(end_nodes), temp, a = abundances) # Store all branch abundances present for this value of x
abundance_sum <- sum(abund_list[[j]])
df_list[j] <- list(data.frame("S_i" = abundance_sum,
"x" = (min(df_node_info_ed$x)))) # Append abundance and corresponding value of x
df_node_info_ed <- df_node_info_ed[-(which(df_node_info_ed$x == min(df_node_info_ed$x))),] # Remove branch/s corresponding to x value
}
}
# Combine dataframes
DF_S_i <- Reduce(rbind, df_list)
return(list(DF_S_i, abund_list))
}
# Calculates integral for each ancestor
calculate_integral <- function(tree, node, curr_ancestor, S_i, abundances, index_letter,
q, individual){
if (length(S_i["x"] > 1)){
l_i <- max(S_i["x"]) # Select longest branch length of a immediate descendant
}else{
l_i <- S_i["x"] # If only one value, select that
}
if (l_i == 0){ # h = 0 do not do integral
if (individual == TRUE){
return(0)
}else{
return(c(0,0,0))
}
}
h <- distance(tree,curr_ancestor,node) # Distance between current node and ancestor
# Assign distance to parent
if (curr_ancestor == (length(tree$tip.label) + 1)){ # If ancestor is the root node
d_parent <- l_i  # By definition its Inf, but integral is only nonzero to l_i
}else{
d_parent <- tree$edge.length[which(tree$edge[,2] == curr_ancestor)] + h
}
# Ancestor integral
int_2 <- 0 # Initialise sum
prev_x <- h # Keep track of x, h as integral is from h
if (l_i <= h){ # Nodes furthest away child is closer than distance to ancestor
int_2 <- 0
if (individual == TRUE){
return(0)
}else{
return(c(0,0,0))
}
}else{
current_row <- which(S_i[,"x"] > h)[1] # Start sum over first x that "reaches" ancestor
while (current_row <= length(S_i[,"x"])) { # Sum over all rows of S_i
x_s <- S_i[current_row,2] # Current value of x for S_i
value_s <- S_i[current_row,1] # Current value of S_i for given x
if (x_s > d_parent){
int_2 <- int_2 + (value_s * (d_parent - prev_x)) # Integral
prev_x <- x_s
break # Exit while loop
}else { # x_s < d_parent
int_2 <- int_2 + (value_s * (x_s - prev_x)) # Sum integral
prev_x <- x_s # Update previous x
current_row <- current_row + 1 # Move to next row
}
}
}
# S_i_ed <- S_i
# if (l_i <= h){ # Nodes furthest away child is closer than distance to ancestor
#   int_2 <- 0
#   if (individual == TRUE){
#     return(0)
#   }else{
#     return(c(0,0,0))
#   }
# }else{
#   S_i_ed$x[which(S_i_ed$x > h)][1] <- S_i_ed$x[which(S_i_ed$x > h)][1] - h # starts integral from correct place
#   if (any(S_i_ed$x > d_parent)){ # passes ancestor, need to change end x value
#     ind <- which(S_i_ed$x > d_parent)[1]
#     if (ind < length(S_i_ed$x)){ # delete irrelevant data
#       S_i_ed <- S_i_ed[-((ind+1):length(S_i_ed$x)),]
#     }
#     S_i_ed$x[ind] <- d_parent # integral only as far as ancestor
#
#   }
#   if (length(S_i_ed$x) > 1){ # change x to be region size if more than one value
#     S_i_ed$x[2:length(S_i_ed$x)] <- S_i$x[2:length(S_i_ed$x)] - S_i_ed$x[1:(length(S_i_ed$x)-1)]
#   }
#   int_2 <- sum(S_i_ed$x * S_i_ed$S)
# }
integral <- function(df){
prev_x <- 0 # Keep track of x
current_row_s <- 1 # Start sum over rows of S_i
current_row_i <- 1 # Start sum over rows of index value
int_1 <- 0 # Initialise integral sum
# qD/1J integral
while ((current_row_s <= length(S_i[,"x"]))&(current_row_i <= length(df$x))){ # Sum over all rows of S_i
x_s <- S_i[current_row_s,2] # Current value of x for S_i
x_i <- df[current_row_i, 2] # Current value of x for qD/J_i_a
value_s <- S_i[current_row_s,1] # Current value of S_i for given x
value_i <- df[current_row_i,1] # Current value of qD/J_i_a for given x
if (x_s < x_i){
int_1 <- int_1 + (value_s * value_i * (x_s - prev_x)) # Sum integral
prev_x <- x_s # Update previous x
current_row_s <- current_row_s + 1 # Move to next row
}else if (isTRUE(all.equal(x_s, x_i))){
int_1 <- int_1 + (value_s * value_i * (x_s - prev_x)) # Sum integral
prev_x <- x_s # Update previous x
current_row_s <- current_row_s + 1 # Move to next row
current_row_i <- current_row_i + 1 # Move to next row
}else{ # x_i > x_s
if (x_i < l_i){
int_1 <- int_1 + (value_s * value_i * (x_i - prev_x)) # Sum integral
prev_x <- x_i # Update previous x
}else{ # x_i > l_i
int_1 <- int_1 + (value_s * value_i * (l_i - prev_x)) # Sum integral
prev_x <- x_i # Update previous x
}
current_row_i <- current_row_i + 1 # Move to next row
}
}
return(int_1)
}
if (int_2 != 0){
Sum_i_a <- calculate_DJ_i_a(tree, node, abundances, curr_ancestor, h, l_i,
index_letter, q, individual)
if (individual == TRUE){
int <- integral(Sum_i_a)*int_2
}else{
int <- sapply(Sum_i_a, integral)*int_2
}
}else if (any(int_2 == 0)){
if (individual == TRUE){
int <- 0
}else{
int <- c(0,0,0)
}
}
return(int)
}
# Calculates qD_i/1J_i, the index value for node i
calculate_DJ_i <- function(tree, node, abundances, index_letter, q, individual){
ancestors <- c(ListAncestors(tree$edge[,1], tree$edge[,2], node), node) # List of ancestors of node
S_i_all <- compute_T_i_S_i(tree, node, abundances) # Run function
T_i <- S_i_all[[1]] # Select value of T_i
S_i <- S_i_all[[2]] # Select S_i dataframe
if (T_i != 0){ # Has a descendant branch with branch length greater than zero
DJ_i <- sapply(ancestors, calculate_integral, tree=tree, node=node, S_i=S_i,
abundances=abundances, index_letter = index_letter, q = q,
individual=individual)
if (individual == FALSE){
dj_i <- apply(DJ_i,1,sum)
D1_i <- (1/T_i) * dj_i[1]
J1_i <- (1/T_i) *dj_i[2]
D0_i <- (1/T_i) *dj_i[3]
v <- c(D1_i, J1_i, D0_i)
}else if (individual == TRUE){
dj_i <- sum(DJ_i)
v <- (1/T_i) * dj_i
}
}else{
if (individual == FALSE){
v <- c(0, 0, 0)
}else if (individual == TRUE){
v <- 0
}
}
return(v)
}
# Calculates longitudinal or star mean for D for q=0 or 1, or J for q =1,
# or all for one mean type
long_star <- function(file, node_abundances = FALSE, mean_type, index_letter = "D",
q = 1, individual = FALSE){
index_letter <- toupper(index_letter)
mean_type <- toupper(mean_type)
tree <- read_convert(file)
node <- tree$edge[1,1] # Root node
if (is.data.frame(node_abundances)){ # If tree has abundance data
abundances <- abundance_phylo(tree, node_abundances) # Calculate branch/node abundances
}else if (!(is.data.frame(node_abundances))){ #if doesn't, assign leaves to be equally abundant, internal nodes size zero
num_tips <- tree$edge[1,1] - 1
tree$tip.label<- as.character(c(1:num_tips))
num_nodes <- tree$Nnode
tree$node.label<- as.character(c((num_tips+1):(num_tips + num_nodes)))
node_abundances <- data.frame("names" = c(tree$node.label, tree$tip.label),
"values" = rep(c(0, (1/num_tips)), times=c(tree$Nnode, num_tips)))
abundances <- abundance_phylo(tree, node_abundances) # Calculate branch/node abundances
}
# Chooses mean type
if (toupper(mean_type) == "LONGITUDINAL"){
S_i_a_res <- calculate_S_i_a(tree, node, abundances, node, 0, sum(tree$edge.length)) # Run function
}else if (toupper(mean_type) == "STAR"){
S_i_a_res <- calculate_S_i_a_star(tree, node, node_abundances) # Run function
}
# Calculate value/s
df_S_i_a <- S_i_a_res[[1]] # Select dataframe
abund_list <- S_i_a_res[[2]] # Select abundance list
# Function to calculate index/indices sum/s
sum_function <- function(abund_vec, x, S, individual, index_letter){
# Calculates index values
if (individual == TRUE) { # One index
if (index_letter == "J") { # J for q = 1
if (length(abund_vec) != 1) { # More than one branch in region
h <- (sum(-(abund_vec)*log((abund_vec/S), base=length(abund_vec))) * x)
}else if (length(abund_vec) == 1) { # Only one branch in region
h <- (1 * S * x)
}
}else{ # D
# Check desired index
if (q == 1){ # q = 1
h <- (sum(-(abund_vec)*log((abund_vec/S))) * x)
}else if (q == 0){ # q = 0
h <- (S * x * log(length(abund_vec), base=exp(1)))
}
}
return(h)
}else if (individual == FALSE){ # All indices
h1 <- (sum(-(abund_vec)*log((abund_vec/S))) * x)
h0 <- (S * x * log(length(abund_vec), base=exp(1)))
if (length(abund_vec) != 1){ # More than one branch in region
j1 <- (sum(-(abund_vec)*log((abund_vec/S), base=length(abund_vec))) * x)
}else if (length(abund_vec) == 1){ # Only one branch in region
j1 <- (1 * S * x)
}
return(c(h0, h1, j1))
}
}
# Calculate size of regions
X <- append(df_S_i_a$x[1], diff(df_S_i_a$x))
# Calculate index values
values <- mapply(sum_function, abund_vec = abund_list, S = df_S_i_a$S_i, x = X,
individual=individual, index_letter=index_letter)
# Calculate normalisation term
T_S_sum <- sum(df_S_i_a$S_i * X)
# Normalise index/indices
if (individual == TRUE){ # Single index
if (index_letter == "J"){ # J
H <- (sum(values)/T_S_sum)
}else{ # D
H <- exp((sum(values)/T_S_sum))
}
}else if (individual == FALSE){ # All indices
if (mean_type == "STAR"){ # Star mean
H <- list("D0S" = exp((sum(values[1,])/T_S_sum)),
"D1S" = exp((sum(values[2,])/T_S_sum)),
"J1S" = sum(values[3,])/T_S_sum)
}else if(mean_type == "LONGITUDINAL"){ # Longitudinal mean
H <- list("D0L" = exp((sum(values[1,])/T_S_sum)),
"D1L" = exp((sum(values[2,])/T_S_sum)),
"J1L" = sum(values[3,])/T_S_sum)
}
}
return(H)
}
# Calculates node-wise mean for D for q = 0 or 1, or for J for q = 1, or all
node <- function(file, node_abundances = FALSE, index_letter = "D", q = 1,
individual = FALSE){
tree <- read_convert(file)
index_letter <- toupper(index_letter)
if (is.data.frame(node_abundances)){ # Has abundance data
abundances <- abundance_phylo(tree, node_abundances) # Calculate branch/node abundances
}else if (!(is.data.frame(node_abundances))){ #Doesn't, assign leaves to be equally abundance, internal nodes size zero
num_tips <- tree$edge[1,1] - 1
tree$tip.label<- as.character(c(1:num_tips))
num_nodes <- tree$Nnode
tree$node.label<- as.character(c((num_tips+1):(num_tips + num_nodes)))
node_abundances <- data.frame("names" = c(tree$node.label, tree$tip.label),
"values" = rep(c(0, (1/num_tips)), times=c(tree$Nnode, num_tips)))
abundances <- abundance_phylo(tree, node_abundances) # Calculate branch/node abundances
}
# Calculates h_bar
T <- 0 # Initialise sum
for (i in 1:length(tree$edge[,1])){
T <- T + (abundances[[as.character(tree$edge[i,2])]] * tree$edge.length[i])
}
nodes <- c((length(tree$tip.label)+1):(length(tree$tip.label) + tree$Nnode)) # All internal node numbers
if (individual == FALSE){ # Calculates all node-averaged indices
DJ <- sapply(nodes, calculate_DJ_i, tree=tree, abundances = abundances,
individual = individual, q = q, index_letter = "D")
D1N <- (1/T)*sum(DJ[1,])
J1N <- (1/T)*sum(DJ[2,])
D0N <- (1/T)*sum(DJ[3,])
List <- list("D1N"= exp(D1N),"J1N" = J1N,"D0N" = exp(D0N))
return(List)
}else if (individual == TRUE){ # Calculates one index
DJ <- sapply(nodes, calculate_DJ_i, tree=tree, abundances = abundances,
individual = individual, index_letter = index_letter, q = q)
if (index_letter == "J"){
index <- (1/T)*sum(DJ)
}else if (!(index_letter == "J")){
index <- exp((1/T)*sum(DJ))
}
return(index)
}
}
# Returns a list of all index values, key is letter for index with first number second
# e.g. 1JN has key J1N
all_indices <- function(file, node_abundances = FALSE){
node <- node(file, node_abundances, "D", 1, FALSE)
star <- long_star(file, node_abundances, "Star", "D", 0, FALSE)
long <- long_star(file, node_abundances, "Longitudinal", "D", 0, FALSE)
values <- list("D0N"= node$D0N,"D1N" = node$D1N,"J1N" = node$J1N, "D0S" = star$D0S,
"D1S" = star$D1S, "J1S" = star$J1S, "D0L" = long$D0L, "D1L" = long$D1L,
"J1L" = long$J1L)
return(values)
}
microbenchmark(all_indices(tree))
f <- "C:\\Users\\44795\\OneDrive\\Documents\\Data\\HIV trees\\PIC38051.tre"
tree <- ape::read.tree(f)
microbenchmark(all_indices(tree))
f <- "C:\\Users\\44795\\OneDrive\\Documents\\Data\\HIV trees\\PIC38051.tre"
tree <- ape::read.tree(f)
microbenchmark(all_indices(tree))
setwd("C:/Users/44795/OneDrive/Documents/RUIindices")
library(devtools)
document()
document()
document()
build()
install()
setwd("C:\\Users\\44795\\OneDrive\\Documents")
boundary_driven_moleculartree <- attr(readRDS("boundary_driven_moleculartree.rds"), "phylo")
boundary_indices <- all_indices(boundary_driven_moleculartree)
library(RUIindices)
boundary_driven_moleculartree <- attr(readRDS("boundary_driven_moleculartree.rds"), "phylo")
boundary_indices <- all_indices(boundary_driven_moleculartree)
boundary_driven_moleculartree <- attr(readRDS("boundary_driven_moleculartree.rds"), "phylo")
boundary_indices <- all_indices(boundary_driven_moleculartree)
setwd("C:/Users/44795/OneDrive/Documents/RUIindices/R")
library(devtools)
build()
doum
document()
build()
install()
